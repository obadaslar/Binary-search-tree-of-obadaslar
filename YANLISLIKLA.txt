#include "binarytreeofobada.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define COMPARE(a, b) (((a) > (b)) - ((a) < (b)))
// Compare Functions
void Print_int(int* a) {
    printf("%d, ", *a);
}
void Print_float(float* a) {
    printf("%f, ", *a);
}
void Print_double(double* a){
    printf("%f, ", *a);
}
int Compare_int(void* a, void* b) {
    return COMPARE(*(int*)a, *(int*)b);
}
int Compare_float(void* a, void* b) {
    return COMPARE(*(float*)a, *(float*)b);
}
int Compare_double(void* a, void* b){
    return COMPARE(*(double*)a, *(double*)b);
}
void New_Binarytree(BinaryTree* tree, size_t ST, CompareFn cf, PrintFn pf) {  
    tree->head = NULL;
    tree->size_Type = ST;
    tree->compare_function = cf;
    tree->compare_function = pf;
}

static void Free_Node_BST(Node* node) {
	if (node == NULL) return;
    Free_Node_BST(node->left);// Free left side
    Free_Node_BST(node->right);
    free(node->data);
    free(node);
    node = NULL;
    return;
}
void Free_Binarytree(BinaryTree* tree) {
    if (!tree) return;
    Free_Node_BST(tree->head);
    tree->head = NULL;
}
static void Add_element_Node_BST(BinaryTree* tree, Node** node, void* Ndata){
    if(*node == NULL) {
        *node = malloc(sizeof(Node));
        if (!(*node)){return;}
        (*node)->data = malloc(tree->size_Type);
        memcpy( (*node)->data, Ndata, tree->size_Type);

        (*node)->left = NULL;
        (*node)->right = NULL;
        return;}
    int r = tree->compare_function(Ndata, (*node)->data);
    if (r > 0) {Add_element_Node_BST(tree, &(*node)->right, Ndata);return;} 
    else if (r < 0) {Add_element_Node_BST(tree, &(*node)->left, Ndata);return;} 
    return;
}

void Add_element_Binarytree(BinaryTree* tree,void* Ndata) {
    if (!(tree->head)){
        tree->head = malloc(sizeof(Node));
        if (!(tree->head)){return;}
        tree->head->data = malloc(tree->size_Type);
        memcpy( tree->head->data, Ndata, tree->size_Type);
        tree->head->left = NULL;
        tree->head->right = NULL;
        return;
    }
    int r = tree->compare_function(Ndata, tree->head->data);
    if (r > 0) {Add_element_Node_BST(tree, &tree->head->right, Ndata);return;}
    else if (r < 0) {Add_element_Node_BST(tree, &tree->head->left, Ndata);return;}
    return;
}

static void Print_Node_BST_InOrder(Node* node){
    if(!node) return;
    Print_Node_BST_InOrder_double(node->left);
    Print_double();
    printf("%f, ", *(double*)node->data);
    Print_Node_BST_InOrder_double(node->right);
    return;
}

void Print_Binarytree_InOrder(BinaryTree* tree){
    Print_Node_BST_InOrder_double(tree->head);
}

//void Print_Binarytree_TREE(){
//}
// Header
#ifndef BINARY_TREE_OF_OBADA_H
#define BINARY_TREE_OF_OBADA_H
// struct of node
#include <stdlib.h>
typedef int (*CompareFn)(void*, void*);
typedef int (*PrintFn)(void*, void*);
typedef struct Node {
	
	struct Node* left;// SMALLER
    struct Node* right;// BIGGER
	void* data;
	
}Node;
// struct of list
typedef struct BinaryTree{
	Node* head;
	size_t size_Type;
	CompareFn compare_function;
	PrintFn print_function;
}BinaryTree;
//Prototips of functions
void New_Binarytree(BinaryTree* tree,size_t ST, CompareFn cf);
void Free_Binarytree(BinaryTree* tree);
void Add_element_Binarytree(BinaryTree* tree, void* Ndata);
void Print_Binarytree_InOrder_double(BinaryTree* tree);
int Compare_int(void* a, void* b);
int Compare_double(void* a, void* b); 
int Compare_float(void* a, void* b);
#define BST_init(tree, type) New_Binarytree(&tree, sizeof(type), (__##type))
#endif